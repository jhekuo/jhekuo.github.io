[{"content":"第一章 基础算法 包括排序，二分，高精度，前缀和与差分，位运算，离散化，区间合并\n消除同步  ios::sync_with_stdio(false);//让cin和标准输入输出不同步，提高cin的读取速度，不能再使用scanf和printf了。 scanf/getchar和cin不要一起用，printf/puts/putchar和cout不要一起用。 可以使用freopen  还可以加上 cin.tie(0) 来解除c++运行库层面的对数据传输的绑定。\n排序 1. 快速排序 基于分治。\n 确定一个分界点，比如（以1开始）,取q[1]，q[(1+r)/2] ,q[r]， 随机为x 调整区间，小于等于x的在左边，大于等于x的在右边。等于x的可以在左边也可以在右边，也可以在边界上，不稳定。 递归处理左右两段。    方法一:\n 开两个额外的数组,a[]，b[] 扫描q数组，如果q[i] ≤ x，存入a，如果q[i]\u0026gt;x，存入b。 然后将a数组的数存入q，b数组的数存入q。    方法二：\n i和j指针，i指向初始，j指向末尾。然后i向右走，直到遇到一个大于x的数。j向左走，直到遇到一个小于等于x的数。然后交换，直到 j ≤ i.  模板：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 1e6 + 10; int n; int q[N]; void quick_sort(int q[], int l, int r) { if (l \u0026gt;= r) return; int x = q[(l+r) \u0026gt;\u0026gt; 1], i = l - 1, j = r + 1; while( i \u0026lt; j){ do i ++ ; while (q[i] \u0026lt; x); do j -- ; while (q[j] \u0026gt; x); if (i \u0026lt; j ) swap(q[i],q[j]); } //j可能比i小，也可能等于i。  quick_sort(q, l, j); //也可以换成 l, i -1  quick_sort(q, j + 1, r); //换成 i, r  //后来说明不能换成i，因为也是会出现死循环问题。  //遇到这种情况，就考虑0,1。  //用j的话，x不能取右边界，（j可以取q[l]、q[(l+r)/2]）  //j不能取 q[r]、q[(l+r+1)/2]  //用i的话，x不能取左边界。 (i可以取q[r]、q[(l+r+1)/2])  //i不能取 q[l]、q[(l+r)/2] } //当下面换成i,r时，不能取x=q[l]，因为会出现死循环的问题。比如排序1，2 //i最终为0，j也是0，这样使用quick_sort()会死循环。 //同理，如果取j+1,r，不能取右边界。  int main(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i = 0; i \u0026lt; n; i ++ ) scanf(\u0026#34;%d\u0026#34;,\u0026amp;q[i]); quick_sort(q,0,n-1); for(int i = 0; i \u0026lt; n; i ++ ) printf(\u0026#34;%d \u0026#34;,q[i]); return 0; } 排序的话，可以使用 #include\u0026lt;algorithm\u0026gt;sort(q, q+n);     2.归并排序 类似快排，也是分治。\n 以中间点为分界点。 递归排序左边和右边。 归并左右两个有序的数组为1个有序的数组。  对两个数组，取两个指针指向数组的左端点。然后比较他们的值，取较小者，然后移动指针，接着继续比较，直到一个指针到头，然后将另一个数组的剩余值取走。 当指针指向的值相同时，取左边数组的值，保持稳定，这说明归并排序是稳定的。快排是不稳定的。而让快排稳定的话，可以用pair。    为什么归并排序是O(nlogn),怎么分析？\n归并排序总共有logn层，每层都是O(n)，所以是O(nlogn)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  #include\u0026lt;iostream\u0026gt; using namespace std; const int N = 1e6 + 10; int n; int q[N], tmp[N]; void merge_sort(int q[], int l, int r) { if (l \u0026gt;= r) return; int mid = (l + r) \u0026gt;\u0026gt; 1; //+优先级比\u0026gt;\u0026gt;大，可以不加括号 \tmerge_sort(q, l, mid), merge_sort(q, mid + 1, r); int k = 0, i = l, j = mid + 1; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= r) if (q[i] \u0026lt;= q[j]) tmp[k++] = q[i++]; else tmp[k++] = q[j++]; while ( i \u0026lt;= mid) tmp[k++] = q[i++]; while ( j \u0026lt;= r) tmp[k++] = q[j++];\tfor ( i = l, j = 0; i \u0026lt;= r; i++, j++) q[i] = tmp[j]; } int main(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i = 0; i \u0026lt; n; i ++ ) scanf(\u0026#34;%d\u0026#34;,\u0026amp;q[i]); merge_sort(q, 0, n-1); for(int i = 0; i \u0026lt; n; i ++ ) printf(\u0026#34;%d \u0026#34;,q[i]); return 0; }   二分 1. 整数二分 模板：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  // 区间[l,r]被划分为[l,mid]与[mid + 1,r]时用 int bsearch_1(int l, int r) { while( l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (check(mid)) r= mid; //check判断mid是否满足性质 \telse l = mid + 1; } return l; } //区间[l,r]被划分成[l, mid - 1]和[mid, r]时使用。 int bsearch_2(int l, int r){ while(l \u0026lt; r) {\tint mid = l + r + 1 \u0026gt;\u0026gt; 1; if(check(mid)) l = mid; else r = mid -1; } return l; }    二分的本质：寻找区间的边界。边界的左边满足某种性质，边界的右边满足另一种性质。   mid = (l+r+1)/2 找红色的边界点,检测中间值是否满足check。  check检查是否满足红色。 if mid满足check，那么需要向右找，那么 l = mid; [mid, r] if mid不满足check，那么需要向左找，那么r = mid -1：[l , mid - 1]   mid = (l + r)/ 2寻找绿色的边界点。check检测是否满足绿色。  if mid 满足 check, 那么需要向左找，那么 r = mid; [l , mid] if mid 不满足 check, 那么需要向右找，那么 l = mid + 1; [mid + 1, r]    为什么第一个需要mid = (l + r + 1)/2 ，因为如果r = l + 1，如果不加一，那么mid = l，区间的更新为：[l,r] 和[l,l]，陷入了死循环。\n所以总的来说，我们如何使用上面两个？\n1，2，2，3，3，4。\n找3的起始坐标和终止坐标。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  //https://www.acwing.com/problem/content/791/ #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 1e5 + 10; int n,m; int q[N]; int main(){ scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for(int i = 0; i \u0026lt; n; i++ ) scanf(\u0026#34;%d\u0026#34;, \u0026amp;q[i]); while(m--){ int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); int l = 0, r = n -1; while ( l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (q[mid] \u0026gt;= x){ //找起始坐标 \tr = mid; } else l = mid + 1; } // l == r \tif (q[l] != x) cout \u0026lt;\u0026lt; \u0026#34;-1 -1\u0026#34; \u0026lt;\u0026lt; endl; else { cout \u0026lt;\u0026lt; l \u0026lt;\u0026lt; \u0026#34; \u0026#34;; int l = 0, r = n - 1; while (l \u0026lt; r){ int mid = (l + r + 1) \u0026gt;\u0026gt; 1; if (q[mid] \u0026lt;= x) l = mid; // l =mid，需要 l+r+1 \u0026gt;\u0026gt; 1 \telse r = mid - 1; } cout \u0026lt;\u0026lt; l \u0026lt;\u0026lt; endl; } } return 0; }   2. 浮点数二分 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  #include\u0026lt;iostream\u0026gt; using namespace std; int main(){ double x; cin \u0026gt;\u0026gt; x; double l = 0, r= x; while( r - l \u0026gt; 1e-6){ //1e8 \tdouble mid = (l+r)/2; if (mid * mid \u0026gt;= x) r = mid; else l = mid; } /* 迭代100次; for (int i = 0; i \u0026lt; 100; i++){ double mid = (l+r)/2; if (mid * mid \u0026gt;= x)\tr = mid; else l = mid; } */\tprintf(\u0026#34;%lf\\n\u0026#34;, l); return 0; } //保留几位小数，增加2有效位。保留2位，1e-4   三次方根：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  #include\u0026lt;iostream\u0026gt;#include\u0026lt;cmath\u0026gt;using namespace std; int main(){ double x; cin \u0026gt;\u0026gt; x; double l = -1000, r= 1000; while( r - l \u0026gt; 1e-8){ double mid = (l+r)/2; if (mid * mid *mid \u0026gt;= x) r = mid; else l = mid; } printf(\u0026#34;%lf\\n\u0026#34;, l); return 0; }   牛顿迭代法求平方根：a 是待求平方根的数\n$$x = \\frac{x^2_0+a}{2x_0}$$\n如何通俗易懂地讲解牛顿迭代法求开方？数值分析？ - 杨华的回答 - 知乎 https://www.zhihu.com/question/20690553/answer/15864267\n高精度 只有C++需要关注。Python默认数是无限大，Java有大整数BigInteger和BigDecimal。\n A + B A - B A * a len(A) ≤ 10^6 a ≤ 10^9 A / a 求商和余数  存储方法：比如 123456789\n 给一个数组a[9]，那么a[0] = 9，a[1] = 8，……a[8] = 1，数组的低位存数字的低位。  加法： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  #include\u0026lt;iostream\u0026gt;#include\u0026lt;vector\u0026gt;#include\u0026lt;string\u0026gt; using namespace std; const int N = 1e6 + 10; vector\u0026lt;int\u0026gt; add(vector\u0026lt;int\u0026gt; \u0026amp;A, vector\u0026lt;int\u0026gt;\u0026amp;B){ vector\u0026lt;int\u0026gt; C; int t = 0; //进位  for(int i = 0; i \u0026lt; A.size() || i \u0026lt; B.size(); i ++){ if (i \u0026lt; A.size()) t += A[i]; if (i \u0026lt; B.size()) t += B[i]; C.push_back(t % 10); t /= 10; } if(t) C.push_back(t); return C; } /* vector\u0026lt;int\u0026gt; add(vector\u0026lt;int\u0026gt; \u0026amp;A, vector\u0026lt;int\u0026gt;\u0026amp;B){ vector\u0026lt;int\u0026gt; C; if (A.size() \u0026lt; B.size()) return add(B,A); int t = 0; //进位 for(int i = 0; i \u0026lt; A.size(); i ++){ t += A[i]; if (i \u0026lt; B.size()) t += B[i]; C.push_back(t % 10); t /= 10; } if(t) C.push_back(t); return C; } */ int main(){ string a,b; vector\u0026lt;int\u0026gt; A,B; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; for (int i = a.size() - 1; i \u0026gt;= 0; i --) A.push_back(a[i] - \u0026#39;0\u0026#39;); for (int i = b.size() - 1; i \u0026gt;= 0; i --) B.push_back(b[i] - \u0026#39;0\u0026#39;); auto C = add(A,B); for (int i = C.size() - 1; i \u0026gt;= 0; i --) printf(\u0026#34;%d\u0026#34;,C[i]); return 0; }   如果每一个存放不止一位数字：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67  #include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt; using namespace std; const int base = 1000000000; vector\u0026lt;int\u0026gt; add(vector\u0026lt;int\u0026gt; \u0026amp;A, vector\u0026lt;int\u0026gt; \u0026amp;B) { if (A.size() \u0026lt; B.size()) return add(B, A); vector\u0026lt;int\u0026gt; C; int t = 0; for (int i = 0; i \u0026lt; A.size(); i ++ ) { t += A[i]; if (i \u0026lt; B.size()) t += B[i]; C.push_back(t % base); t /= base; } if (t) C.push_back(t); return C; } int main() { string a, b; vector\u0026lt;int\u0026gt; A, B; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; for (int i = a.size() - 1, s = 0, j = 0, t = 1; i \u0026gt;= 0; i -- ) { s += (a[i] - \u0026#39;0\u0026#39;) * t; j ++, t *= 10; if (j == 9 || i == 0) { A.push_back(s); s = j = 0; t = 1; } } for (int i = b.size() - 1, s = 0, j = 0, t = 1; i \u0026gt;= 0; i -- ) { s += (b[i] - \u0026#39;0\u0026#39;) * t; j ++, t *= 10; if (j == 9 || i == 0) { B.push_back(s); s = j = 0; t = 1; } } auto C = add(A, B); cout \u0026lt;\u0026lt; C.back(); for (int i = C.size() - 2; i \u0026gt;= 0; i -- ) printf(\u0026#34;%09d\u0026#34;, C[i]); cout \u0026lt;\u0026lt; endl; return 0; } 作者：yxc 链接：https://www.acwing.com/activity/content/code/content/39792/ 来源：AcWing 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。   减法： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  #include\u0026lt;iostream\u0026gt;#include\u0026lt;string\u0026gt;#include\u0026lt;vector\u0026gt; using namespace std; const int N = 1e5 + 10; bool cmp(vector\u0026lt;int\u0026gt; \u0026amp;A, vector\u0026lt;int\u0026gt;\u0026amp;B) { if (A.size() != B.size()) return A.size() \u0026gt; B.size(); for(int i = A.size() - 1 ; i \u0026gt;= 0; i--) if(A[i] != B[i]) return A[i] \u0026gt; B[i]; return true; } vector\u0026lt;int\u0026gt; sub(vector\u0026lt;int\u0026gt;\u0026amp;A, vector\u0026lt;int\u0026gt;\u0026amp;B){ vector\u0026lt;int\u0026gt; C; for (int i = 0, t =0; i \u0026lt; A.size(); ++ i){ t = A[i] - t; if (i \u0026lt; B.size()) t -= B[i]; C.push_back((t + 10) % 10); //数学，当t小于0，就可以+10，而如果t \u0026gt;=0， 就无影响；  if ( t \u0026lt; 0) t = 1; //有借位  else t = 0; } while(C.size() \u0026gt; 1 \u0026amp;\u0026amp; C.back() == 0) C.pop_back(); return C; } int main(){ string a,b; vector\u0026lt;int\u0026gt; A,B; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; for(int i = a.size() - 1; i \u0026gt;= 0; -- i) A.push_back(a[i] - \u0026#39;0\u0026#39;); for(int i = b.size() - 1; i \u0026gt;= 0; -- i) B.push_back(b[i] - \u0026#39;0\u0026#39;); if (cmp(A,B)) { auto C = sub(A,B); for (int i = C.size() - 1; i \u0026gt;= 0; -- i) printf(\u0026#34;%d\u0026#34;, C[i]); } else { auto C = sub(B,A); printf(\u0026#34;-\u0026#34;); for (int i = C.size() - 1; i \u0026gt;= 0; -- i) printf(\u0026#34;%d\u0026#34;, C[i]); } return 0; }   乘法： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  #include\u0026lt;iostream\u0026gt;#include\u0026lt;string\u0026gt;#include\u0026lt;vector\u0026gt; using namespace std; const int N = 1e5 + 10; vector\u0026lt;int\u0026gt; mul(vector\u0026lt;int\u0026gt;\u0026amp;A, int b){ vector\u0026lt;int\u0026gt; C; int t = 0; for(int i = 0; i \u0026lt; A.size() || t; ++ i) { if (i \u0026lt; A.size()) t += A[i] * b; C.push_back(t % 10); t /= 10; } while(C.size() \u0026gt; 1 \u0026amp;\u0026amp; C.back() == 0) C.pop_back(); return C; } int main(){ string a; int b; vector\u0026lt;int\u0026gt; A; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; for(int i = a.size() - 1; i \u0026gt;= 0; -- i) A.push_back(a[i] - \u0026#39;0\u0026#39;); auto C = mul(A,b); for (int i = C.size() - 1; i \u0026gt;= 0; -- i) printf(\u0026#34;%d\u0026#34;, C[i]); return 0; }   除法： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  #include\u0026lt;iostream\u0026gt;#include\u0026lt;string\u0026gt;#include\u0026lt;vector\u0026gt;#include\u0026lt;algorithm\u0026gt; using namespace std; vector\u0026lt;int\u0026gt; div(vector\u0026lt;int\u0026gt; \u0026amp;A, int b, int \u0026amp;r) { vector\u0026lt;int\u0026gt; C; r = 0; for(int i = A.size() - 1; i \u0026gt;= 0; -- i) { r = r * 10 + A[i]; C.push_back(r / b); r %= b; } reverse(C.begin(), C.end()); while(C.size() \u0026gt; 1 \u0026amp;\u0026amp; C.back() == 0) C.pop_back(); return C; } int main(){ string a; int b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; vector\u0026lt;int\u0026gt; A; for(int i = a.size() - 1; i \u0026gt;= 0; -- i) A.push_back(a[i] - \u0026#39;0\u0026#39;); int r = 0; auto C = div(A, b, r); for(int i = C.size() - 1; i \u0026gt;= 0; -- i) printf(\u0026#34;%d\u0026#34;, C[i]); cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; r \u0026lt;\u0026lt; endl; return 0; }   前缀和 与 差分 前缀和与差分是逆运算。\n前缀和：  一个长度为n的数组 然后前缀和数组,Si = 前i个数的和（从a1、a2到ai）。 定义$S_0 = 0$;  问题是如何求Si，求前i个和即可。\n！作用：求一段数字的和。比如求[l, r]，那么就是求\n$$S_r - S_{l-1}$$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  #include\u0026lt;iostream\u0026gt; using namespace std; const int N = 1e5 + 10; int n, m; int a[N], s[N]; int main(){ //ios::sync_with_stdio(false);//让cin和标准输入输出不同步，提高cin的读取速度，不能再使用scanf和printf了。  //可以，但是scanf/getchar和cin不要一起用，printf/puts/putchar和cout不要一起用。  //可以使用freopen。  cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; ++ i) scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); for (int i = 1; i \u0026lt;= n; ++ i) s[i] = s[i - 1] + a[i]; while(m --) { int l,r; scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;l,\u0026amp;r); printf(\u0026#34;%d\\n\u0026#34;,s[r] - s[l - 1]); } return 0; }   二维前缀和 从$(x_1,y_1)\\ to \\ (x_2,y_2)$，的区域的面积。那么就是：\n$$S_{x_2y_2}-S_{x_2(y_1-1)}-S_{(x_1-1)y_2}+S_{(x_1-1)(y_1-1)}$$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  #include\u0026lt;iostream\u0026gt; using namespace std; int n, m, q; const int N = 1e3 + 10; int a[N][N], s[N][N]; int main(){ cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt;= n; ++ i) for (int j = 1; j \u0026lt;= m; ++ j){ scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i][j]); s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j]; } while(q --){ int x1,y1,x2,y2; scanf(\u0026#34;%d%d%d%d\u0026#34;, \u0026amp;x1,\u0026amp;y1,\u0026amp;x2,\u0026amp;y2); printf(\u0026#34;%d\\n\u0026#34;, s[x2][y2] - s[x1 - 1][y2] - s[x2][y1-1] + s[x1-1][y1-1]); } return 0; }   差分 a数组是b数组的前缀和，b数组是a的差分。\n对于a1, a2, a3……an\n构造 b1, b2, b3, bn\n使得 aj = b1 + b2 + …… + bj\n用处：a和b数组在O（n）时间可以相互转化。\n让al到ar，[l, r]的数都加上c，用差分只要O(1)。只要让$b_l+c$，然后让 $b_{r+1}-c$\n可以假定a数组和b数组全是零，只要看插入操作，即在[1, 1]的数都加上a1, [2,2]的数都加上a2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  #include\u0026lt;iostream\u0026gt; using namespace std; const int N = 1e5 + 10; int n, m; int a[N], b[N]; void insert(int l, int r, int c) { b[l] += c; b[r + 1] -= c; } int main(){ cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; ++ i) scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); for (int i = 1; i \u0026lt;= n; ++ i) insert(i, i, a[i]); while(m --) { int l, r, c; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;l, \u0026amp;r, \u0026amp;c); insert(l, r, c); } for (int i = 1; i \u0026lt;= n; ++ i) { b[i] += b[i-1]; //求前缀和  printf(\u0026#34;%d \u0026#34;, b[i]); } return 0; }   差分矩阵 初始化时，也是可以相当于在(i, j)和(i, j)之间增加$a_{i,j}$\nb数组是a数组的差分，a数组是b数组的前缀和。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  #include\u0026lt;iostream\u0026gt; using namespace std; const int N = 1e3 + 10; int n, m, q; int a[N][N], b[N][N]; void insert(int x1, int y1, int x2, int y2, int c) { b[x1][y1] += c; b[x2 + 1][y1] -= c; b[x1][y2+1] -=c; b[x2+1][y2+1] +=c; } int main(){ cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt;= n; ++ i) for (int j = 1; j \u0026lt;= m; ++ j) scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i][j]); for (int i = 1; i \u0026lt;= n; ++ i) for (int j = 1; j \u0026lt;= m; ++ j) insert(i,j,i,j,a[i][j]); while(q --) { int x1,y1,x2,y2,c; scanf(\u0026#34;%d%d%d%d%d\u0026#34;, \u0026amp;x1, \u0026amp;y1, \u0026amp;x2, \u0026amp;y2, \u0026amp;c); insert(x1, y1, x2, y2, c); } for (int i = 1; i \u0026lt;= n; ++ i) { for (int j = 1; j \u0026lt;= m; ++ j){ b[i][j] += b[i -1][j] + b[i][j -1] - b[i- 1][j-1]; printf(\u0026#34;%d \u0026#34;, b[i][j]); } puts(\u0026#34;\u0026#34;); } return 0; }   双指针算法 包括归并排序\n1 2 3 4  for(int i = 0, j = 0; i \u0026lt; n; ++ i){ while( j \u0026lt; i \u0026amp;\u0026amp; check(i, j)) ++ j; //具体逻辑 }   核心思想：把O(n^2)两重循环 变成 O(n).\n举个例子，输入一个句子，输出每个单词：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  #include\u0026lt;iostream\u0026gt;#include\u0026lt;cstring\u0026gt; using namespace std; int main() { char str[1000]; cin.getline(str, 1000); int n = strlen(str); for (int i = 0; i \u0026lt; n; ++ i) { int j = i; while( j \u0026lt; n \u0026amp;\u0026amp; str[j] !=\u0026#39; \u0026#39;) ++ j; for (int k = i; k \u0026lt; j; k ++) cout \u0026lt;\u0026lt; str[k]; cout \u0026lt;\u0026lt; endl; i = j; } return 0; }   799. 最长连续不重复子序列\ncheck检验是否有重复元素\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  //数据很大时可以用hash table来做 #include\u0026lt;iostream\u0026gt; using namespace std; const int N = 1e5 + 10; int n; int a[N], s[N]; int main() { cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; ++ i ) scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i]); int res = 0; for (int i = 0, j = 0; i \u0026lt; n; ++ i ) { ++ s[a[i]]; while (j \u0026lt;= i \u0026amp;\u0026amp; s[a[i]] \u0026gt; 1) { -- s[a[j]]; ++ j; } res = max(res, i - j + 1); } cout \u0026lt;\u0026lt; res; return 0; }   位运算 第k位的值  n的二进制表示中，第k位是几？个位是第零位。  先把第k位移到最后一位， n \u0026raquo; k 再看个位是几。x \u0026amp; 1. 即 (n \u0026raquo; k) \u0026amp; 1，\u0026raquo;运算符的优先级大于 \u0026amp;，可以不加括号。    lowbit操作。 可以用来统计x中的1的数量。\nlowbit(x)，返回x的最后一位的1。\nLowbit( 1010) ——\u0026gt; 得到最后一个1。\n1 2 3  -x = ~x + 1。 补码表示。 那么 x \u0026amp; -x = x \u0026amp; ( ~x + 1)   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  #include\u0026lt;iostream\u0026gt; using namespace std; int lowbit(int x) { return x \u0026amp; -x; } int main (){ int n; cin \u0026gt;\u0026gt; n; while(n--){ int x; cin \u0026gt;\u0026gt; x; int res = 0; while(x) x -= lowbit(x), ++ res; cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } return 0; }   一个数 -x 的：\n原码：最高位取1.\n反码：各位取反\n补码：各位取反，加一。\n离散化 整数的离散化：\n值域为$0-{10}^9$，个数有$10^5$。映射到0-n\n比如a[]: 1, 3, 100, 2000, 500000. 将它们映射到0，1，2，3，4，\n注意：\n a[]中可能有重复的元素，需要去重 如何算出a[i] 离散化后的值是多少？二分。  unique是将alls数组进行去重，将重复元素放在末尾，返回值是一个迭代器，指向非重复元素的最后一个，然后在删除这些元素就好。\n找到第一个≥ x的位置, 这个是边界问题。\n返回r+1是映射到1,2,……n\nUnique 如何实现Unique函数？\n比如1 1 2 2 2 3 4 5 5 5 6\n1 2 3 4 5 6 7 8 9 10 11  vector\u0026lt;int\u0026gt;::iterator unique(vector\u0026lt;int\u0026gt; \u0026amp;a) { int j = 0; for(int i = 0; i \u0026lt; a.size(); ++ i ) { if (!i || a[i] != a[i-1]) a[j++] = a[i] } return a.begin() + j; }   区间和： 如果数据比较小，就是前缀和和差分的问题。但是这个问题的数据量比较大，而且有负数。\n这个问题，是插入的数量比较小。虽然跨度有10亿个，但是查询和插入的数量都是十万不到。所以需要离散化。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71  #include\u0026lt;iostream\u0026gt;#include\u0026lt;vector\u0026gt;#include\u0026lt;algorithm\u0026gt; using namespace std; typedef pair\u0026lt;int, int\u0026gt; PII; const int N = 300010; int n,m; int a[N], s[N]; vector\u0026lt;int\u0026gt; alls; vector\u0026lt;PII\u0026gt; add, query; int find(int x) { int l = 0, r = alls.size() - 1; while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (alls[mid] \u0026gt;= x) r = mid; else l = mid + 1; } return r + 1; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for(int i = 0; i \u0026lt; n; ++ i ) { int x, c; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; c; add.push_back({x,c}); alls.push_back(x); } for(int i = 0; i \u0026lt; m; ++ i) { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; query.push_back(make_pair(l,r)); alls.push_back(l); alls.push_back(r); } sort(alls.begin(), alls.end()); alls.erase(unique(alls.begin(), alls.end()), alls.end()); for(auto item : add) { int x = find(item.first); a[x] += item.second; } for (int i = 1; i \u0026lt;= alls.size(); ++ i) s[i] = s[i - 1] + a[i]; for (auto item: query) { int l = find(item.first), r = find(item.second); cout \u0026lt;\u0026lt; s[r] - s[l - 1] \u0026lt;\u0026lt; endl; } return 0; }   区间合并 把有重叠点的区间合并\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  #include\u0026lt;iostream\u0026gt;#include\u0026lt;algorithm\u0026gt;#include\u0026lt;vector\u0026gt; using namespace std; const int N = 200010; typedef pair\u0026lt;int, int\u0026gt; PII; vector\u0026lt;PII\u0026gt; segs; int n; void merge(vector\u0026lt;PII\u0026gt; \u0026amp; segs) { vector\u0026lt;PII\u0026gt; res; sort(segs.begin(), segs.end()); //先排first，再排second  int st = -2e9, ed = -2e9; //st = start, ed = end  for(auto seg : segs) { if (ed \u0026lt; seg.first) { if (st != -2e9) res.push_back({st, ed}); st = seg.first, ed = seg.second; } else { ed = max(ed, seg.second); } } if (st != -2e9) res.push_back({st, ed}); segs = res; } int main() { cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; ++ i) { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; segs.push_back({l, r}); } merge(segs); cout \u0026lt;\u0026lt; segs.size() \u0026lt;\u0026lt; endl; return 0; }   ","permalink":"https://imingx.github.io/posts/algorithm_01/","summary":"第一章 基础算法 包括排序，二分，高精度，前缀和与差分，位运算，离散化，区间合并\n消除同步  ios::sync_with_stdio(false);//让cin和标准输入输出不同步，提高cin的读取速度，不能再使用scanf和printf了。 scanf/getchar和cin不要一起用，printf/puts/putchar和cout不要一起用。 可以使用freopen  还可以加上 cin.tie(0) 来解除c++运行库层面的对数据传输的绑定。\n排序 1. 快速排序 基于分治。\n 确定一个分界点，比如（以1开始）,取q[1]，q[(1+r)/2] ,q[r]， 随机为x 调整区间，小于等于x的在左边，大于等于x的在右边。等于x的可以在左边也可以在右边，也可以在边界上，不稳定。 递归处理左右两段。    方法一:\n 开两个额外的数组,a[]，b[] 扫描q数组，如果q[i] ≤ x，存入a，如果q[i]\u0026gt;x，存入b。 然后将a数组的数存入q，b数组的数存入q。    方法二：\n i和j指针，i指向初始，j指向末尾。然后i向右走，直到遇到一个大于x的数。j向左走，直到遇到一个小于等于x的数。然后交换，直到 j ≤ i.  模板：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  #include \u0026lt;iostream\u0026gt; using namespace std; const int N = 1e6 + 10; int n; int q[N]; void quick_sort(int q[], int l, int r) { if (l \u0026gt;= r) return; int x = q[(l+r) \u0026gt;\u0026gt; 1], i = l - 1, j = r + 1; while( i \u0026lt; j){ do i ++ ; while (q[i] \u0026lt; x); do j -- ; while (q[j] \u0026gt; x); if (i \u0026lt; j ) swap(q[i],q[j]); } //j可能比i小，也可能等于i。  quick_sort(q, l, j); //也可以换成 l, i -1  quick_sort(q, j + 1, r); //换成 i, r  //后来说明不能换成i，因为也是会出现死循环问题。  //遇到这种情况，就考虑0,1。  //用j的话，x不能取右边界，（j可以取q[l]、q[(l+r)/2]）  //j不能取 q[r]、q[(l+r+1)/2]  //用i的话，x不能取左边界。 (i可以取q[r]、q[(l+r+1)/2])  //i不能取 q[l]、q[(l+r)/2] } //当下面换成i,r时，不能取x=q[l]，因为会出现死循环的问题。比如排序1，2 //i最终为0，j也是0，这样使用quick_sort()会死循环。 //同理，如果取j+1,r，不能取右边界。  int main(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i = 0; i \u0026lt; n; i ++ ) scanf(\u0026#34;%d\u0026#34;,\u0026amp;q[i]); quick_sort(q,0,n-1); for(int i = 0; i \u0026lt; n; i ++ ) printf(\u0026#34;%d \u0026#34;,q[i]); return 0; } 排序的话，可以使用 #include\u0026lt;algorithm\u0026gt;sort(q, q+n);     2.","title":"「Algorithm」01 基础算法"},{"content":" 链表与邻接表：树与图的存储 栈与队列：单调队列、单调栈 kmp Trie 并查集 堆 Hash表  链表与邻接表：树与图的存储 用数组来模拟这些结构，不适用struct和STL。目的是为了提高效率\n1 2 3 4 5 6 7  struct Node { int val; Node * next; }; Node * p = new Node();   面试题较多，但是new一个节点是比较慢的，做题不需要。\n用数组模拟单链表 最常用的邻接表，存储图和树。它们都是用邻接表存储的。\n以上是用数组e[N]和数组ne[N]来模拟单链表，如果是不存在，那么取-1。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70  #include\u0026lt;iostream\u0026gt; using namespace std; const int N = 1e5 + 10; // head 表示头结点的下标 // e[i]是节点i的值 // ne[i] 是节点i的next指针 // idx是一个指针，指向当前用到的点。 int head, e[N], ne[N], idx; void init() { head = -1; idx = 0; } //将x插入到头结点 void add_to_head(int x) { e[idx] = x, ne[idx] = head, head = idx, idx ++; } //将x插入到下标是k的点的后面 void add(int k, int x) { e[idx] = x, ne[idx] = ne[k], ne[k] = idx, idx ++; } //删除k后面的节点 void remove(int k) { ne[k] = ne[ne[k]]; } int main() { int m; cin \u0026gt;\u0026gt; m; init(); while ( m --) { int k, x; char op; cin \u0026gt;\u0026gt; op; if (op == \u0026#39;H\u0026#39;) { cin \u0026gt;\u0026gt; x; add_to_head(x); } else if( op == \u0026#39;D\u0026#39;) { cin \u0026gt;\u0026gt; k; if (k == 0) head = ne[head]; else remove(k - 1); }else { cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; x; add(k - 1, x); } } for (int i = head; i != -1; i = ne[i]) cout \u0026lt;\u0026lt; e[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; return 0; }   用数组模拟双链表 用来优化某些问题。\nint l[N], r[N];，让0是head，1是tail\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  #include\u0026lt;iostream\u0026gt; using namespace std; const int N = 100010; int m; int e[N], l[N], r[N], idx; void init() { //0表示左端点，1表示右端点  r[0] = 1; l[1] = 0; idx = 2; } void add(int k, int x) { //在k的右边插入x  e[idx] = x; r[idx] = r[k]; l[idx] = k; l[r[k]] = idx; r[k] = idx; idx ++; //如果想插入左边，只要add(l[k], x) } void remove(int k) { r[l[k]] = r[k]; l[r[k]] = l[k]; } int main() { cin \u0026gt;\u0026gt; m; }   邻接表，就是n个单链表.\n栈与队列 栈就是先进后出。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  #include\u0026lt;iostream\u0026gt; using namespace std; const int N = 100010; int stk[N], tt; int main() { 初始化 //tt = -1;  入栈 //stk[ ++ tt] = x;  出栈 // return stk[tt --];  空 //if (tt \u0026gt;= 0) return true;  //else return false;  栈顶 //stk[tt]; } 实际上，令tt = 0初始化，更简洁。 判空时，只要 if (tt \u0026gt; 0) return true; // if(tt) return true; \telse return false;   队列：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  int q[N], hh = 0, tt = -1; //hh是队头， tt是队尾。队尾插入，队头弹出  //插入 q[ ++ tt] = x; //弹出： return q[hh ++]; if( hh \u0026lt;= tt) not empty; else empty; 取出队头队尾元素： return q[hh]; return q[tt];   考验记忆力和毅力（自制力）。\n单调栈： 给定一个序列，求序列中的每一个数，离他最近的左边比他小的数。否则为-1。\n我们设置一个栈，对于每个x，之前的元素，应该让stk[tt] ≥ x的都出栈。\n这样x再入栈，就是一个单调递增的栈序列。而找到最小的，只要找到x入栈前的栈顶即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  #include\u0026lt;iostream\u0026gt; using namespace std; const int N = 1e5 + 10; int n; int stk[N], tt; int main() { cin \u0026gt;\u0026gt; n; for(int i = 0; i \u0026lt; n; ++ i) { int x; cin \u0026gt;\u0026gt; x; while(tt \u0026amp;\u0026amp; stk[tt] \u0026gt;= x) tt --; if (tt) cout \u0026lt;\u0026lt; stk[tt] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; else cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; stk[++tt] = x; } return 0; } //这个算法，每个元素都最多入栈和出栈一次，所以复杂度是O（n）   单调队列 https://www.acwing.com/problem/content/156/滑动窗口\n一个序列，在一个窗口内，算出其最大值和最小值，窗口逐渐向右移动。\n在一个窗口内，如果右边的元素比左边的元素小，\n 首先考虑暴力怎么做。 然后考虑在窗口移动的时候，怎样删除一些无用的元素。  如果不开O2优化，那么数组比STL快一些。\nO3优化\n1  #pragma GCC optimize(2)   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  #include\u0026lt;iostream\u0026gt; using namespace std; const int N = 1e6 + 10; int a[N], q[N]; //q是下标，也就是队列，a只是记录的值a[q[i]]是取下标的值。 int n, k; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for(int i = 0; i \u0026lt; n; ++ i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } int hh = 0, tt = -1; for(int i = 0; i \u0026lt; n; i ++) { //判断队头是否已经出窗口  if (hh \u0026lt;= tt \u0026amp;\u0026amp; i - k + 1 \u0026gt; q[hh]) { ++ hh; } //形成一个单调递增的序列。  while(hh \u0026lt;= tt \u0026amp;\u0026amp; a[q[tt]] \u0026gt;= a[i]) tt --; q[++tt] = i; if (i \u0026gt;= k - 1) printf(\u0026#34;%d \u0026#34;, a[q[hh]]); } puts(\u0026#34;\u0026#34;); hh = 0, tt = -1; for(int i = 0; i \u0026lt; n; ++ i) { if( hh \u0026lt;= tt \u0026amp;\u0026amp; i - q[hh] + 1 \u0026gt; k) ++ hh; while( hh \u0026lt;= tt \u0026amp;\u0026amp; a[q[tt]] \u0026lt;= a[i]) tt --; q[++tt] = i; if (i \u0026gt;= k - 1) printf(\u0026#34;%d \u0026#34;, a[q[hh]]); } }   KMP  暴力算法怎么做？ 如何去优化。  朴素算法：\n S[N]→ p[M] for(int i = 1; i ≤ n; ++i)\nbool flag = true;\nint t = i;\nfor(int j = 1; j ≤ m; j++, t++)\nif (s[t] ≠ p[j])\n{\nflag = false;\nbreak;\n}\n KMP解释（以1开始）\nnext数组表示，next[i] = j，表示p[1, j] = p[ i - j + 1, i]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  #include\u0026lt;iostream\u0026gt;#include\u0026lt;cstdio\u0026gt; using namespace std; const int N = 100010, M = 1000010; int n, m; char p[N], s[M]; int ne[N]; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; p + 1 \u0026gt;\u0026gt; m \u0026gt;\u0026gt; s + 1; //index from 1  // 求Next  for(int i = 2, j = 0; i \u0026lt;= n; ++ i) { //每次都比较 j+1与i，到最后之前，可以保证1-j已经是匹配的。除非j = 0  while(j \u0026amp;\u0026amp; p[i] != p[ j + 1]) j = ne[j]; if(p[i] == p[j+1]) j++; ne[i] = j; //前j个（1-j）的元素与[i-j +1, i]的元素匹配，所以ne[i] = j  } for(int i = 1, j = 0; i \u0026lt;=m ; ++ i) { while(j \u0026amp;\u0026amp; s[i] != p[ j + 1]) j = ne[j]; if( s[i] == p[j+1]) j++; if(j == n)//前n个元素已经匹配  { //匹配成功  printf(\u0026#34;%d \u0026#34;, i - n ); j = ne[j]; } } return 0; }   Trie树 高效地存储和查找字符串，集合的数据结构\n比如：\n abcdef abdef aced bcdf bcff cdaa dcdc\n 当数量过大，可以使用二进制来表示。比如考虑汉字，直接找其二进制100000101010,每一步仅考虑1和0.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  #include\u0026lt;iostream\u0026gt;#include\u0026lt;cstdio\u0026gt; using namespace std; const int N = 100010; int son[N][26], cnt[N], idx; //下标是0的点，既是根节点，又是空节点 char str[N]; void insert(char str[]) { int p = 0; for(int i = 0; str[i]; ++i){ int u = str[i] - \u0026#39;a\u0026#39;; if (!son[p][u]) son[p][u] = ++ idx; p = son[p][u]; } cnt[p] ++; } int query(char str[]) { int p = 0; for(int i = 0; str[i]; ++i) { int u = str[i] - \u0026#39;a\u0026#39;; if(!son[p][u]) return 0; p = son[p][u]; } return cnt[p]; } int main() { int n; cin \u0026gt;\u0026gt; n; while(n--) { char op[2]; cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; str; if (op[0] == \u0026#39;I\u0026#39;) insert(str); else cout \u0026lt;\u0026lt; query(str) \u0026lt;\u0026lt; endl; } return 0; }   并查集 面试和比赛，非常容易出的数据结构。\n用来快速的处理：\n 将两个集合合并 询问两个元素是否在一个集合当中  belong[x] = a，存储x属于集合a。\n近乎O（1）的支持上面的两个操作。\n基本原理：每个集合用一棵树来表示，树根的编号就是整个集合的编号，每个节点存储它的父节点，p[x] 表示父节点。\n 问题1： 如何判断树根 p== x, x就是集合的编号 问题2：如何求x的集合编号，while(p! = x) x = p 问题3：如何合并两个集合：假设px是x的集合的编号，py是y的集合的编号，那么p= y;  并查集的优化：\n （路径压缩）, 每次查询其父节点，只要直接指向其祖宗节点。  合并集合\nhttps://www.acwing.com/problem/content/838/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  #include\u0026lt;iostream\u0026gt;#include\u0026lt;cstdio\u0026gt; using namespace std; const int N = 1e5 + 10; int p[N]; int n, m; int find(int x) //返回x的祖宗节点，加上路径压缩 { if(p[x] != x) p[x] = find(p[x]); return p[x]; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for(int i = 1; i \u0026lt;=n ; ++ i) p[i] = i; while(m --) { char op[2]; //建议读入一个字符，也要使用字符串，自动过滤空格和回车  int a, b; cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; if(op[0] == \u0026#39;M\u0026#39;) p[find(a)] = find(b); else { if(find(a) == find(b)) puts(\u0026#34;Yes\u0026#34;); else puts(\u0026#34;No\u0026#34;); } } }   连通块中点的数量https://www.acwing.com/problem/content/839/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  #include\u0026lt;iostream\u0026gt;#include\u0026lt;cstdio\u0026gt; using namespace std; const int N = 1e5 + 10; //如何查询每个联通块的数量？维护根节点的size即可。 int p[N], siz[N]; int n, m; int find(int x) //返回x的祖宗节点，加上路径压缩 { if(p[x] != x) p[x] = find(p[x]); return p[x]; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for(int i = 1; i \u0026lt;=n ; ++ i) { p[i] = i; siz[i] = 1; } while(m --) { char op[5]; //建议读入一个字符，也要使用字符串，自动过滤空格和回车  int a, b; cin \u0026gt;\u0026gt; op; if(op[0] == \u0026#39;C\u0026#39;) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; if(find(a) != find(b)) siz[find(b)] += siz[find(a)]; p[find(a)] = find(b); } else if (op[1] == \u0026#39;1\u0026#39;) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; if(find(a) == find(b)) puts(\u0026#34;Yes\u0026#34;); else puts(\u0026#34;No\u0026#34;); } else { cin \u0026gt;\u0026gt; a; cout \u0026lt;\u0026lt; siz[find(a)] \u0026lt;\u0026lt; endl; } } }   堆 如何手写一个堆？\n 插入一个数 求集合当中的最小值 删除最小值 删除任意一个元素 修改任意一个元素  堆的基本结构：\n是一棵二叉树。是一棵完全二叉树。\n以小顶堆为例，每个节点的左右子节点都大于该节点的值。\n使用一个一维数组存放堆。\n1号点是根节点，x的左儿子是2x，右子节点是2x+1。\n操作：\n down(x)，往下调整x。每次找这个节点和两个子节点的最小值，然后交换即可。 up(x)，往上调整x。每次往上和父节点比较，需要交换时交换即可。  怎么插入x？\n heap[ ++ idx] = x; up(x);  最小值：\n heap[1]  删除最小值：\n heap[1] = heap[idx]; idx—; down(1);  删除任意元素\n heap[k] = heap[size], size—; down(k); up(k);  修改元素：\n heap[k] = x; down(k); up(k);  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  #include\u0026lt;iostream\u0026gt;#include\u0026lt;algorithm\u0026gt; using namespace std; const int N = 100010; int n, m; int h[N], idx; void down(int u) { int t = u; if (u * 2 \u0026lt;= idx \u0026amp;\u0026amp; h[u * 2] \u0026lt; h[t]) t = u * 2; if (u * 2 + 1 \u0026lt;= idx \u0026amp;\u0026amp; h[u*2 +1] \u0026lt; h[t]) t = u*2 + 1; if(u!=t){ swap(h[u], h[t]); down(t); } } void up(int u) { while( u / 2 \u0026amp;\u0026amp; h[ u/2 ] \u0026gt; h[u]) { swap(h[u/2], h[u]); u/=2; } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for(int i = 1; i \u0026lt;= n; ++ i) scanf(\u0026#34;%d\u0026#34;, \u0026amp;h[i]); idx = n; for(int i = n/2; i ; -- i) down(i); /*这是建立堆的过程 为什么从n/2开始down？ n/2的子孩子是最后一个元素，是完全二叉树的倒数第二层，所以这样一直递归 的做就好，而且时间复杂度是O(n); */ while(m--) { printf(\u0026#34;%d \u0026#34;, h[1]); h[1] = h[idx]; idx --; down(1); } return 0; }   带映射版的堆操作:\nhttps://www.acwing.com/problem/content/841/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87  #include\u0026lt;iostream\u0026gt;#include\u0026lt;algorithm\u0026gt;#include\u0026lt;cstring\u0026gt; using namespace std; const int N = 100010; int n; int h[N], ph[N], hp[N], idx; //ph存放插入的第k个元素在堆的下标位置 //hp存放的是堆中第j个元素在ph数组的位置索引。 //ph和hp是互为反函数。  void heap_swap(int a, int b) { swap(ph[hp[a]], ph[hp[b]]); swap(hp[a], hp[b]); swap(h[a], h[b]); } void down(int u) { int t = u; if (u * 2 \u0026lt;= idx \u0026amp;\u0026amp; h[u * 2] \u0026lt; h[t]) t = u * 2; if (u * 2 + 1 \u0026lt;= idx \u0026amp;\u0026amp; h[u*2 +1] \u0026lt; h[t]) t = u*2 + 1; if(u!=t){ heap_swap(u, t); down(t); } } void up(int u) { while( u / 2 \u0026amp;\u0026amp; h[ u/2 ] \u0026gt; h[u]) { heap_swap(u/2, u); u/=2; } } int main() { cin \u0026gt;\u0026gt; n; int m = 0; //m是第m个插入的元素。  while(n --) { char op[10]; int k, x; cin \u0026gt;\u0026gt; op; if (!strcmp(op, \u0026#34;I\u0026#34;)) { cin \u0026gt;\u0026gt; x; idx ++; m ++; ph[m] = idx; hp[idx] = m; h[idx] = x; up(idx); } else if (!strcmp(op, \u0026#34;PM\u0026#34;)) cout \u0026lt;\u0026lt; h[1] \u0026lt;\u0026lt; endl; else if (!strcmp(op, \u0026#34;DM\u0026#34;)) { heap_swap(1, idx); idx --; down(1); } else if(!strcmp(op, \u0026#34;D\u0026#34;)) { cin \u0026gt;\u0026gt; k; k = ph[k]; heap_swap(k, idx); idx --; down(k), up(k); } else { cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; x; k = ph[k]; h[k] = x; down(k), up(k); } } return 0; }   find()和cnt()可以改成，get()和cnt()保证不编译错误，compile ERROR。\nHash表   哈希表的存储结构，认为是O(1). 如果要删除，只要开个数组标记一下。\n  开放寻址法\n  拉链法\n  常见情景： 把0-10^9的数映射到0-10^5的数组。\nx mod 10 ^ 5 附近的质数。然后处理冲突。100003.\n和离散化比较，离散是需要保序的。\n  常用的字符串的哈希方式。\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57  //拉链法 #include\u0026lt;iostream\u0026gt;#include\u0026lt;cstring\u0026gt;//有memset using namespace std; const int N = 100003; //取大于10万的最小的质数。  int h[N], e[N], ne[N], idx; void insert(int x) { int k = (x % N + N) % N; //因为有的数是负数。  e[idx] = x; //e存值  ne[idx] = h[k]; //ne存指针  h[k] = idx; idx ++; //插入头部。 } bool find(int x) { int k = (x % N + N) % N; for(int i = h[k]; i != -1; i = ne[i]) { if(e[i] == x) return true; } return false; } int main(){ int n; memset(h, -1, sizeof h); cin \u0026gt;\u0026gt; n; while(n --) { char op[2]; int x; cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; x; if(op[0] == \u0026#39;I\u0026#39;) insert(x); else { if (find(x)) puts(\u0026#34;Yes\u0026#34;); else puts(\u0026#34;No\u0026#34;); } } return 0; }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  //开放寻址法 #include\u0026lt;iostream\u0026gt;#include\u0026lt;cstring\u0026gt; using namespace std; //0xf3f3f3f3是10^9级别，很大，用来初始化数组 const int N = 2e5 + 3, null = 0x3f3f3f3f; //一般取三倍。 //取质数。 int h[N]; int find(int x) { int k = (x % N + N) % N; while(h[k] != null \u0026amp;\u0026amp; h[k] != x) { k ++; if(k == N) k = 0; } //这个过程一定会停止的，因为总共只有1e5个数字，而N是二倍，所以不担心满;  //结束条件时，h[k] == null 或 h[k] == x  return k; } int main(){ int n; cin \u0026gt;\u0026gt; n; memset(h, 0x3f, sizeof h); while(n --) { char op[2]; int x; cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; x; int k = find(x); if (op[0] == \u0026#39;I\u0026#39;) { h[k] = x; } else { if (h[k] != null) puts(\u0026#34;Yes\u0026#34;); else puts(\u0026#34;No\u0026#34;); } } return 0; }   字符串前缀哈希法。\n str = \u0026ldquo;ABCDEF\u0026rdquo; h[1] = \u0026ldquo;A\u0026rdquo; // 前1个 h[2] = \u0026ldquo;AB\u0026rdquo;\n 即处理前缀的hash，h[0] = 0\n如果对字符串进行哈希？当成p进制数，a * p ^ 3 + b * p * 2 ……;再取模Q。\n不能把字母映射成0.\n那么前缀哈希值有什么用呢？因为我们已经知道 h[L]到h[R]的哈希值\n所以求L - R的哈希值，只要 h[R] - h[L - 1] * p ^ {R-L+1};\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  #include\u0026lt;iostream\u0026gt;#include\u0026lt;cstring\u0026gt; using namespace std; typedef unsigned long long ULL; const int N = 100010, P = 131; int n, m; char str[N]; ULL h[N], p[N]; //p是存放P的n次方  ULL get(int l, int r) { return h[r] - h[l - 1] * p[r - l + 1]; } int main(){ cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; str + 1; p[0] = 1; for(int i = 1; i \u0026lt;= n; ++ i) { p[i] = p[i - 1] * P; h[i] = h[i - 1] * P + str[i]; } while( m --) { int l1, r1, l2, r2; cin \u0026gt;\u0026gt; l1 \u0026gt;\u0026gt; r1 \u0026gt;\u0026gt; l2 \u0026gt;\u0026gt; r2; if(get(l1, r1) == get(l2, r2)) { puts(\u0026#34;Yes\u0026#34;); } else { puts(\u0026#34;No\u0026#34;); } } return 0; }   hash算法求两个字符串相同比KMP更好\nKMP更适合循环节。\nC++STL使用 1 2 3 4 5 6 7 8 9 10 11 12 13  vector 可变长数组，倍增的思想 string 处理字符串的利器，substr(), c_str() queue, 队列，进行push(),front(), pop() priority_queue，优先队列，堆，push(), top(), pop() stack 栈，Push(), top(), pop() deque 双端队列 set, map, multiset, multimap 基于平衡二叉树（红黑树）动态维护有序序列 unordered_set, unordered_map, unordered_multiset, unordered_multimap 哈希表 bitset;压位 list用的不多。   vector: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  #include\u0026lt;iostream\u0026gt;#include\u0026lt;cstdio\u0026gt;#include\u0026lt;cstring\u0026gt;#include\u0026lt;algorithm\u0026gt;#include\u0026lt;vector\u0026gt; using namespace std; int main() { vector\u0026lt;int\u0026gt; a(10, 3); vector\u0026lt;int\u0026gt; b[10]; //定义数组  //定义一个长度为10的，初始值为3的vector  //for(auto x : a) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl;  a.size(); //O(1)  a.empty(); a.clear();//清空  /*系统分配空间时，所需时间与空间大小无关，与申请次数有关！！！ 所以尽量减少申请空间的次数。 vector最初分配32的空间，然后如果不够，分配64，然后copy过去之前的元素。 申请长度为2 ^ n的数组，那么需要copy(1 + 2 + 2^n-1) = 2^n可以认为是O(1) 申请空间的次数是log(2^n) = n */ a.front(); a.back(); a.push_back(); a.pop_back(); begin(); end(); []; a \u0026lt; b可以判断两个vector的大小，按字典序比。 return 0; }   下面是模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124  C++ STL简介 vector, 变长数组，倍增的思想 size() 返回元素个数 empty() 返回是否为空 clear() 清空 front()/back() push_back()/pop_back() begin()/end() [] 支持比较运算，按字典序 pair\u0026lt;int, int\u0026gt;p; first, 第一个元素 second, 第二个元素 支持比较运算，以first为第一关键字，以second为第二关键字（字典序） p = make_pair(10, 2); p = {10, 2}; pair\u0026lt;int, pair\u0026lt;int, int\u0026gt;\u0026gt;p;存三个 string，字符串 size()/length() 返回字符串长度 empty() clear() substr(起始下标，(子串长度)) 返回子串 c_str() 返回字符串所在字符数组的起始地址 用于用printf输出 支持加运算： string a = \u0026#34;1\u0026#34;; a += \u0026#34;bcd\u0026#34;; queue, 队列 size() empty() push() 向队尾插入一个元素 front() 返回队头元素 back() 返回队尾元素 pop() 弹出队头元素 priority_queue, 优先队列，默认是大顶堆 size() empty() push() 插入一个元素 top() 返回堆顶元素 pop() 弹出堆顶元素 定义成小顶堆的方式： priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; q; priority_queue\u0026lt;int\u0026gt; heap; 可以通过插入-x实现小顶堆。 stack, 栈 size() empty() push() 向栈顶插入一个元素 top() 返回栈顶元素 pop() 弹出栈顶元素 deque, 双端队列，加强版vector，效率低，尽量不用 size() empty() clear() front()/back() push_back()/pop_back() push_front()/pop_front() begin()/end() 迭代器 [] 支持直接索引 set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列 size() empty() clear() begin()/end() ++, -- 返回前驱和后继，时间复杂度 O(logn) set/multiset set不允许重复元素 insert() 插入一个数 find() 查找一个数，返回迭代器，找不到返回end迭代器 count() 返回某一个数的个数 erase() (1) 输入是一个数x，删除所有x O(k + logn) (2) 输入一个迭代器，删除这个迭代器 lower_bound()/upper_bound() lower_bound(x) 返回大于等于x的最小的数的迭代器 upper_bound(x) 返回大于x的最小的数的迭代器 map/multimap insert() 插入的数是一个pair erase() 输入的参数是pair或者迭代器 find() [] 注意multimap不支持此操作。 时间复杂度是 O(logn) lower_bound()/upper_bound() map\u0026lt;string ,int\u0026gt; a; a[\u0026#34;yxc\u0026#34;] = 1; cout \u0026lt;\u0026lt; a[\u0026#34;yec\u0026#34;] \u0026lt;\u0026lt; endl; unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表 和上面类似，增删改查的时间复杂度是 O(1) 不支持 lower_bound()/upper_bound()， 迭代器的++，--. bitset, 圧位 是bool数组的1/8。🐂 bitset\u0026lt;10000\u0026gt; s; ~s; ~, \u0026amp;, |, ^ \u0026gt;\u0026gt;, \u0026lt;\u0026lt; ==, != [] count() 返回有多少个1 any() 判断是否至少有一个1 none() 判断是否全为0 set() 把所有位置成1 set(k, v) 将第k位变成v reset() 把所有位变成0 flip() 等价于~ flip(k) 把第k位取反 作者：yxc 链接：https://www.acwing.com/blog/content/404/ 来源：AcWing   ","permalink":"https://imingx.github.io/posts/algorithm_02/","summary":"链表与邻接表：树与图的存储 栈与队列：单调队列、单调栈 kmp Trie 并查集 堆 Hash表  链表与邻接表：树与图的存储 用数组来模拟这些结构，不适用struct和STL。目的是为了提高效率\n1 2 3 4 5 6 7  struct Node { int val; Node * next; }; Node * p = new Node();   面试题较多，但是new一个节点是比较慢的，做题不需要。\n用数组模拟单链表 最常用的邻接表，存储图和树。它们都是用邻接表存储的。\n以上是用数组e[N]和数组ne[N]来模拟单链表，如果是不存在，那么取-1。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70  #include\u0026lt;iostream\u0026gt; using namespace std; const int N = 1e5 + 10; // head 表示头结点的下标 // e[i]是节点i的值 // ne[i] 是节点i的next指针 // idx是一个指针，指向当前用到的点。 int head, e[N], ne[N], idx; void init() { head = -1; idx = 0; } //将x插入到头结点 void add_to_head(int x) { e[idx] = x, ne[idx] = head, head = idx, idx ++; } //将x插入到下标是k的点的后面 void add(int k, int x) { e[idx] = x, ne[idx] = ne[k], ne[k] = idx, idx ++; } //删除k后面的节点 void remove(int k) { ne[k] = ne[ne[k]]; } int main() { int m; cin \u0026gt;\u0026gt; m; init(); while ( m --) { int k, x; char op; cin \u0026gt;\u0026gt; op; if (op == \u0026#39;H\u0026#39;) { cin \u0026gt;\u0026gt; x; add_to_head(x); } else if( op == \u0026#39;D\u0026#39;) { cin \u0026gt;\u0026gt; k; if (k == 0) head = ne[head]; else remove(k - 1); }else { cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; x; add(k - 1, x); } } for (int i = head; i !","title":"「Algorithm」02 Data Structure"},{"content":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define rep(i,a,n) for(int i = a; i\u0026lt; n; i++) #define per(i,a,n) for(int i=n-1; i\u0026gt;=a; i--) #define pb push_back #define mp make_pair #define all(x) (x).begin(), (x).end() #define fi first #define se second #define sz(x) ((int)(x).size()) typedef vector\u0026lt;int\u0026gt; VI; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; PII; typedef double db; mt19937 mrand(random_device{}()); const ll mod = 1000000007; int rnd(int x) { return mrand() % x;} ll mulmod(ll a, ll b) {ll res=0;a%=mod;assert(b\u0026gt;=0);for(;b;b\u0026gt;\u0026gt;=1){if(b\u0026amp;1)res+=a%mod;a+=a%mod;}return res;} ll powmod(ll a, ll b) {ll res=1;a%=mod;assert(b\u0026gt;=0);for(;b;b\u0026gt;\u0026gt;=1){if(b\u0026amp;1)res*=a%mod;a*=a%mod;}return res;} ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a;}   ","permalink":"https://imingx.github.io/posts/code_sample/","summary":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define rep(i,a,n) for(int i = a; i\u0026lt; n; i++) #define per(i,a,n) for(int i=n-1; i\u0026gt;=a; i--) #define pb push_back #define mp make_pair #define all(x) (x).begin(), (x).end() #define fi first #define se second #define sz(x) ((int)(x).size()) typedef vector\u0026lt;int\u0026gt; VI; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; PII; typedef double db; mt19937 mrand(random_device{}()); const ll mod = 1000000007; int rnd(int x) { return mrand() % x;} ll mulmod(ll a, ll b) {ll res=0;a%=mod;assert(b\u0026gt;=0);for(;b;b\u0026gt;\u0026gt;=1){if(b\u0026amp;1)res+=a%mod;a+=a%mod;}return res;} ll powmod(ll a, ll b) {ll res=1;a%=mod;assert(b\u0026gt;=0);for(;b;b\u0026gt;\u0026gt;=1){if(b\u0026amp;1)res*=a%mod;a*=a%mod;}return res;} ll gcd(ll a, ll b) { return b ?","title":"Code Sample"},{"content":" Hi, I\u0026rsquo;m gmm. Welcome to my fantasy world✨.  An undergraduate student. Introvert \u0026amp; diffident.  A little more about me\u0026hellip; 1 2 3 4 5 6 7 8  const ming = { pronouns: \u0026#34;He\u0026#34; | \u0026#34;Him\u0026#34;, code: [\u0026#34;C\u0026amp;C++\u0026#34;, \u0026#34;Python\u0026#34;, \u0026#34;Java\u0026#34;, \u0026#34;Swift\u0026#34;], tools: [\u0026#34;JetBrains suite\u0026#34;, \u0026#34;Jupyter\u0026#34;], architecture: \u0026#34;Nothing\u0026#34;, interest: \u0026#34;Nothing\u0026#34;, goal: \u0026#34;Do my own and keep shining. Be a pessimistic far traveler\u0026#34; };   Nevertheless, I love connecting with different people, so if you want to say hi, I\u0026rsquo;ll be happy to meet you more! :)\n","permalink":"https://imingx.github.io/about/","summary":"Hi, I\u0026rsquo;m gmm. Welcome to my fantasy world✨.  An undergraduate student. Introvert \u0026amp; diffident.  A little more about me\u0026hellip; 1 2 3 4 5 6 7 8  const ming = { pronouns: \u0026#34;He\u0026#34; | \u0026#34;Him\u0026#34;, code: [\u0026#34;C\u0026amp;C++\u0026#34;, \u0026#34;Python\u0026#34;, \u0026#34;Java\u0026#34;, \u0026#34;Swift\u0026#34;], tools: [\u0026#34;JetBrains suite\u0026#34;, \u0026#34;Jupyter\u0026#34;], architecture: \u0026#34;Nothing\u0026#34;, interest: \u0026#34;Nothing\u0026#34;, goal: \u0026#34;Do my own and keep shining. Be a pessimistic far traveler\u0026#34; };   Nevertheless, I love connecting with different people, so if you want to say hi, I\u0026rsquo;ll be happy to meet you more!","title":"About"}]