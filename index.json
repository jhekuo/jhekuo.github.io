[{"content":" 链表与邻接表：树与图的存储 栈与队列：单调队列、单调栈 kmp Trie 并查集 堆 Hash表  链表与邻接表：树与图的存储 用数组来模拟这些结构，不适用struct和STL。目的是为了提高效率\n1 2 3 4 5 6 7  struct Node { int val; Node * next; }; Node * p = new Node();   面试题较多，但是new一个节点是比较慢的，做题不需要。\n用数组模拟单链表 最常用的邻接表，存储图和树。它们都是用邻接表存储的。\n以上是用数组e[N]和数组ne[N]来模拟单链表，如果是不存在，那么取-1。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70  #include\u0026lt;iostream\u0026gt; using namespace std; const int N = 1e5 + 10; // head 表示头结点的下标 // e[i]是节点i的值 // ne[i] 是节点i的next指针 // idx是一个指针，指向当前用到的点。 int head, e[N], ne[N], idx; void init() { head = -1; idx = 0; } //将x插入到头结点 void add_to_head(int x) { e[idx] = x, ne[idx] = head, head = idx, idx ++; } //将x插入到下标是k的点的后面 void add(int k, int x) { e[idx] = x, ne[idx] = ne[k], ne[k] = idx, idx ++; } //删除k后面的节点 void remove(int k) { ne[k] = ne[ne[k]]; } int main() { int m; cin \u0026gt;\u0026gt; m; init(); while ( m --) { int k, x; char op; cin \u0026gt;\u0026gt; op; if (op == \u0026#39;H\u0026#39;) { cin \u0026gt;\u0026gt; x; add_to_head(x); } else if( op == \u0026#39;D\u0026#39;) { cin \u0026gt;\u0026gt; k; if (k == 0) head = ne[head]; else remove(k - 1); }else { cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; x; add(k - 1, x); } } for (int i = head; i != -1; i = ne[i]) cout \u0026lt;\u0026lt; e[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; return 0; }   用数组模拟双链表 用来优化某些问题。\nint l[N], r[N];，让0是head，1是tail\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  #include\u0026lt;iostream\u0026gt; using namespace std; const int N = 100010; int m; int e[N], l[N], r[N], idx; void init() { //0表示左端点，1表示右端点  r[0] = 1; l[1] = 0; idx = 2; } void add(int k, int x) { //在k的右边插入x  e[idx] = x; r[idx] = r[k]; l[idx] = k; l[r[k]] = idx; r[k] = idx; idx ++; //如果想插入左边，只要add(l[k], x) } void remove(int k) { r[l[k]] = r[k]; l[r[k]] = l[k]; } int main() { cin \u0026gt;\u0026gt; m; }   邻接表，就是n个单链表.\n栈与队列 栈就是先进后出。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  #include\u0026lt;iostream\u0026gt; using namespace std; const int N = 100010; int stk[N], tt; int main() { 初始化 //tt = -1;  入栈 //stk[ ++ tt] = x;  出栈 // return stk[tt --];  空 //if (tt \u0026gt;= 0) return true;  //else return false;  栈顶 //stk[tt]; } 实际上，令tt = 0初始化，更简洁。 判空时，只要 if (tt \u0026gt; 0) return true; // if(tt) return true; \telse return false;   队列：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  int q[N], hh = 0, tt = -1; //hh是队头， tt是队尾。队尾插入，队头弹出  //插入 q[ ++ tt] = x; //弹出： return q[hh ++]; if( hh \u0026lt;= tt) not empty; else empty; 取出队头队尾元素： return q[hh]; return q[tt];   考验记忆力和毅力（自制力）。\n单调栈： 给定一个序列，求序列中的每一个数，离他最近的左边比他小的数。否则为-1。\n我们设置一个栈，对于每个x，之前的元素，应该让stk[tt] ≥ x的都出栈。\n这样x再入栈，就是一个单调递增的栈序列。而找到最小的，只要找到x入栈前的栈顶即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  #include\u0026lt;iostream\u0026gt; using namespace std; const int N = 1e5 + 10; int n; int stk[N], tt; int main() { cin \u0026gt;\u0026gt; n; for(int i = 0; i \u0026lt; n; ++ i) { int x; cin \u0026gt;\u0026gt; x; while(tt \u0026amp;\u0026amp; stk[tt] \u0026gt;= x) tt --; if (tt) cout \u0026lt;\u0026lt; stk[tt] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; else cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; stk[++tt] = x; } return 0; } //这个算法，每个元素都最多入栈和出栈一次，所以复杂度是O（n）   单调队列 https://www.acwing.com/problem/content/156/滑动窗口\n一个序列，在一个窗口内，算出其最大值和最小值，窗口逐渐向右移动。\n在一个窗口内，如果右边的元素比左边的元素小，\n 首先考虑暴力怎么做。 然后考虑在窗口移动的时候，怎样删除一些无用的元素。  如果不开O2优化，那么数组比STL快一些。\nO3优化\n1  #pragma GCC optimize(2)   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  #include\u0026lt;iostream\u0026gt; using namespace std; const int N = 1e6 + 10; int a[N], q[N]; //q是下标，也就是队列，a只是记录的值a[q[i]]是取下标的值。 int n, k; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for(int i = 0; i \u0026lt; n; ++ i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } int hh = 0, tt = -1; for(int i = 0; i \u0026lt; n; i ++) { //判断队头是否已经出窗口  if (hh \u0026lt;= tt \u0026amp;\u0026amp; i - k + 1 \u0026gt; q[hh]) { ++ hh; } //形成一个单调递增的序列。  while(hh \u0026lt;= tt \u0026amp;\u0026amp; a[q[tt]] \u0026gt;= a[i]) tt --; q[++tt] = i; if (i \u0026gt;= k - 1) printf(\u0026#34;%d \u0026#34;, a[q[hh]]); } puts(\u0026#34;\u0026#34;); hh = 0, tt = -1; for(int i = 0; i \u0026lt; n; ++ i) { if( hh \u0026lt;= tt \u0026amp;\u0026amp; i - q[hh] + 1 \u0026gt; k) ++ hh; while( hh \u0026lt;= tt \u0026amp;\u0026amp; a[q[tt]] \u0026lt;= a[i]) tt --; q[++tt] = i; if (i \u0026gt;= k - 1) printf(\u0026#34;%d \u0026#34;, a[q[hh]]); } }   KMP  暴力算法怎么做？ 如何去优化。  朴素算法：\n S[N]→ p[M] for(int i = 1; i ≤ n; ++i)\nbool flag = true;\nint t = i;\nfor(int j = 1; j ≤ m; j++, t++)\nif (s[t] ≠ p[j])\n{\nflag = false;\nbreak;\n}\n KMP解释（以1开始）\nnext数组表示，next[i] = j，表示p[1, j] = p[ i - j + 1, i]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  #include\u0026lt;iostream\u0026gt;#include\u0026lt;cstdio\u0026gt; using namespace std; const int N = 100010, M = 1000010; int n, m; char p[N], s[M]; int ne[N]; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; p + 1 \u0026gt;\u0026gt; m \u0026gt;\u0026gt; s + 1; //index from 1  // 求Next  for(int i = 2, j = 0; i \u0026lt;= n; ++ i) { //每次都比较 j+1与i，到最后之前，可以保证1-j已经是匹配的。除非j = 0  while(j \u0026amp;\u0026amp; p[i] != p[ j + 1]) j = ne[j]; if(p[i] == p[j+1]) j++; ne[i] = j; //前j个（1-j）的元素与[i-j +1, i]的元素匹配，所以ne[i] = j  } for(int i = 1, j = 0; i \u0026lt;=m ; ++ i) { while(j \u0026amp;\u0026amp; s[i] != p[ j + 1]) j = ne[j]; if( s[i] == p[j+1]) j++; if(j == n)//前n个元素已经匹配  { //匹配成功  printf(\u0026#34;%d \u0026#34;, i - n ); j = ne[j]; } } return 0; }   Trie树 高效地存储和查找字符串，集合的数据结构\n比如：\n abcdef abdef aced bcdf bcff cdaa dcdc\n 当数量过大，可以使用二进制来表示。比如考虑汉字，直接找其二进制100000101010,每一步仅考虑1和0.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  #include\u0026lt;iostream\u0026gt;#include\u0026lt;cstdio\u0026gt; using namespace std; const int N = 100010; int son[N][26], cnt[N], idx; //下标是0的点，既是根节点，又是空节点 char str[N]; void insert(char str[]) { int p = 0; for(int i = 0; str[i]; ++i){ int u = str[i] - \u0026#39;a\u0026#39;; if (!son[p][u]) son[p][u] = ++ idx; p = son[p][u]; } cnt[p] ++; } int query(char str[]) { int p = 0; for(int i = 0; str[i]; ++i) { int u = str[i] - \u0026#39;a\u0026#39;; if(!son[p][u]) return 0; p = son[p][u]; } return cnt[p]; } int main() { int n; cin \u0026gt;\u0026gt; n; while(n--) { char op[2]; cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; str; if (op[0] == \u0026#39;I\u0026#39;) insert(str); else cout \u0026lt;\u0026lt; query(str) \u0026lt;\u0026lt; endl; } return 0; }   并查集 面试和比赛，非常容易出的数据结构。\n用来快速的处理：\n 将两个集合合并 询问两个元素是否在一个集合当中  belong[x] = a，存储x属于集合a。\n近乎O（1）的支持上面的两个操作。\n基本原理：每个集合用一棵树来表示，树根的编号就是整个集合的编号，每个节点存储它的父节点，p[x] 表示父节点。\n 问题1： 如何判断树根 p== x, x就是集合的编号 问题2：如何求x的集合编号，while(p! = x) x = p 问题3：如何合并两个集合：假设px是x的集合的编号，py是y的集合的编号，那么p= y;  并查集的优化：\n （路径压缩）, 每次查询其父节点，只要直接指向其祖宗节点。  合并集合\nhttps://www.acwing.com/problem/content/838/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  #include\u0026lt;iostream\u0026gt;#include\u0026lt;cstdio\u0026gt; using namespace std; const int N = 1e5 + 10; int p[N]; int n, m; int find(int x) //返回x的祖宗节点，加上路径压缩 { if(p[x] != x) p[x] = find(p[x]); return p[x]; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for(int i = 1; i \u0026lt;=n ; ++ i) p[i] = i; while(m --) { char op[2]; //建议读入一个字符，也要使用字符串，自动过滤空格和回车  int a, b; cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; if(op[0] == \u0026#39;M\u0026#39;) p[find(a)] = find(b); else { if(find(a) == find(b)) puts(\u0026#34;Yes\u0026#34;); else puts(\u0026#34;No\u0026#34;); } } }   连通块中点的数量https://www.acwing.com/problem/content/839/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  #include\u0026lt;iostream\u0026gt;#include\u0026lt;cstdio\u0026gt; using namespace std; const int N = 1e5 + 10; //如何查询每个联通块的数量？维护根节点的size即可。 int p[N], siz[N]; int n, m; int find(int x) //返回x的祖宗节点，加上路径压缩 { if(p[x] != x) p[x] = find(p[x]); return p[x]; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for(int i = 1; i \u0026lt;=n ; ++ i) { p[i] = i; siz[i] = 1; } while(m --) { char op[5]; //建议读入一个字符，也要使用字符串，自动过滤空格和回车  int a, b; cin \u0026gt;\u0026gt; op; if(op[0] == \u0026#39;C\u0026#39;) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; if(find(a) != find(b)) siz[find(b)] += siz[find(a)]; p[find(a)] = find(b); } else if (op[1] == \u0026#39;1\u0026#39;) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; if(find(a) == find(b)) puts(\u0026#34;Yes\u0026#34;); else puts(\u0026#34;No\u0026#34;); } else { cin \u0026gt;\u0026gt; a; cout \u0026lt;\u0026lt; siz[find(a)] \u0026lt;\u0026lt; endl; } } }   堆 如何手写一个堆？\n 插入一个数 求集合当中的最小值 删除最小值 删除任意一个元素 修改任意一个元素  堆的基本结构：\n是一棵二叉树。是一棵完全二叉树。\n以小顶堆为例，每个节点的左右子节点都大于该节点的值。\n使用一个一维数组存放堆。\n1号点是根节点，x的左儿子是2x，右子节点是2x+1。\n操作：\n down(x)，往下调整x。每次找这个节点和两个子节点的最小值，然后交换即可。 up(x)，往上调整x。每次往上和父节点比较，需要交换时交换即可。  怎么插入x？\n heap[ ++ idx] = x; up(x);  最小值：\n heap[1]  删除最小值：\n heap[1] = heap[idx]; idx—; down(1);  删除任意元素\n heap[k] = heap[size], size—; down(k); up(k);  修改元素：\n heap[k] = x; down(k); up(k);  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  #include\u0026lt;iostream\u0026gt;#include\u0026lt;algorithm\u0026gt; using namespace std; const int N = 100010; int n, m; int h[N], idx; void down(int u) { int t = u; if (u * 2 \u0026lt;= idx \u0026amp;\u0026amp; h[u * 2] \u0026lt; h[t]) t = u * 2; if (u * 2 + 1 \u0026lt;= idx \u0026amp;\u0026amp; h[u*2 +1] \u0026lt; h[t]) t = u*2 + 1; if(u!=t){ swap(h[u], h[t]); down(t); } } void up(int u) { while( u / 2 \u0026amp;\u0026amp; h[ u/2 ] \u0026gt; h[u]) { swap(h[u/2], h[u]); u/=2; } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for(int i = 1; i \u0026lt;= n; ++ i) scanf(\u0026#34;%d\u0026#34;, \u0026amp;h[i]); idx = n; for(int i = n/2; i ; -- i) down(i); /*这是建立堆的过程 为什么从n/2开始down？ n/2的子孩子是最后一个元素，是完全二叉树的倒数第二层，所以这样一直递归 的做就好，而且时间复杂度是O(n); */ while(m--) { printf(\u0026#34;%d \u0026#34;, h[1]); h[1] = h[idx]; idx --; down(1); } return 0; }   带映射版的堆操作:\nhttps://www.acwing.com/problem/content/841/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87  #include\u0026lt;iostream\u0026gt;#include\u0026lt;algorithm\u0026gt;#include\u0026lt;cstring\u0026gt; using namespace std; const int N = 100010; int n; int h[N], ph[N], hp[N], idx; //ph存放插入的第k个元素在堆的下标位置 //hp存放的是堆中第j个元素在ph数组的位置索引。 //ph和hp是互为反函数。  void heap_swap(int a, int b) { swap(ph[hp[a]], ph[hp[b]]); swap(hp[a], hp[b]); swap(h[a], h[b]); } void down(int u) { int t = u; if (u * 2 \u0026lt;= idx \u0026amp;\u0026amp; h[u * 2] \u0026lt; h[t]) t = u * 2; if (u * 2 + 1 \u0026lt;= idx \u0026amp;\u0026amp; h[u*2 +1] \u0026lt; h[t]) t = u*2 + 1; if(u!=t){ heap_swap(u, t); down(t); } } void up(int u) { while( u / 2 \u0026amp;\u0026amp; h[ u/2 ] \u0026gt; h[u]) { heap_swap(u/2, u); u/=2; } } int main() { cin \u0026gt;\u0026gt; n; int m = 0; //m是第m个插入的元素。  while(n --) { char op[10]; int k, x; cin \u0026gt;\u0026gt; op; if (!strcmp(op, \u0026#34;I\u0026#34;)) { cin \u0026gt;\u0026gt; x; idx ++; m ++; ph[m] = idx; hp[idx] = m; h[idx] = x; up(idx); } else if (!strcmp(op, \u0026#34;PM\u0026#34;)) cout \u0026lt;\u0026lt; h[1] \u0026lt;\u0026lt; endl; else if (!strcmp(op, \u0026#34;DM\u0026#34;)) { heap_swap(1, idx); idx --; down(1); } else if(!strcmp(op, \u0026#34;D\u0026#34;)) { cin \u0026gt;\u0026gt; k; k = ph[k]; heap_swap(k, idx); idx --; down(k), up(k); } else { cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; x; k = ph[k]; h[k] = x; down(k), up(k); } } return 0; }   find()和cnt()可以改成，get()和cnt()保证不编译错误，compile ERROR。\nHash表   哈希表的存储结构，认为是O(1). 如果要删除，只要开个数组标记一下。\n  开放寻址法\n  拉链法\n  常见情景： 把0-10^9的数映射到0-10^5的数组。\nx mod 10 ^ 5 附近的质数。然后处理冲突。100003.\n和离散化比较，离散是需要保序的。\n  常用的字符串的哈希方式。\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57  //拉链法 #include\u0026lt;iostream\u0026gt;#include\u0026lt;cstring\u0026gt;//有memset using namespace std; const int N = 100003; //取大于10万的最小的质数。  int h[N], e[N], ne[N], idx; void insert(int x) { int k = (x % N + N) % N; //因为有的数是负数。  e[idx] = x; //e存值  ne[idx] = h[k]; //ne存指针  h[k] = idx; idx ++; //插入头部。 } bool find(int x) { int k = (x % N + N) % N; for(int i = h[k]; i != -1; i = ne[i]) { if(e[i] == x) return true; } return false; } int main(){ int n; memset(h, -1, sizeof h); cin \u0026gt;\u0026gt; n; while(n --) { char op[2]; int x; cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; x; if(op[0] == \u0026#39;I\u0026#39;) insert(x); else { if (find(x)) puts(\u0026#34;Yes\u0026#34;); else puts(\u0026#34;No\u0026#34;); } } return 0; }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  //开放寻址法 #include\u0026lt;iostream\u0026gt;#include\u0026lt;cstring\u0026gt; using namespace std; //0xf3f3f3f3是10^9级别，很大，用来初始化数组 const int N = 2e5 + 3, null = 0x3f3f3f3f; //一般取三倍。 //取质数。 int h[N]; int find(int x) { int k = (x % N + N) % N; while(h[k] != null \u0026amp;\u0026amp; h[k] != x) { k ++; if(k == N) k = 0; } //这个过程一定会停止的，因为总共只有1e5个数字，而N是二倍，所以不担心满;  //结束条件时，h[k] == null 或 h[k] == x  return k; } int main(){ int n; cin \u0026gt;\u0026gt; n; memset(h, 0x3f, sizeof h); while(n --) { char op[2]; int x; cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; x; int k = find(x); if (op[0] == \u0026#39;I\u0026#39;) { h[k] = x; } else { if (h[k] != null) puts(\u0026#34;Yes\u0026#34;); else puts(\u0026#34;No\u0026#34;); } } return 0; }   字符串前缀哈希法。\n str = \u0026ldquo;ABCDEF\u0026rdquo; h[1] = \u0026ldquo;A\u0026rdquo; // 前1个 h[2] = \u0026ldquo;AB\u0026rdquo;\n 即处理前缀的hash，h[0] = 0\n如果对字符串进行哈希？当成p进制数，a * p ^ 3 + b * p * 2 ……;再取模Q。\n不能把字母映射成0.\n那么前缀哈希值有什么用呢？因为我们已经知道 h[L]到h[R]的哈希值\n所以求L - R的哈希值，只要 h[R] - h[L - 1] * p ^ {R-L+1};\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  #include\u0026lt;iostream\u0026gt;#include\u0026lt;cstring\u0026gt; using namespace std; typedef unsigned long long ULL; const int N = 100010, P = 131; int n, m; char str[N]; ULL h[N], p[N]; //p是存放P的n次方  ULL get(int l, int r) { return h[r] - h[l - 1] * p[r - l + 1]; } int main(){ cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; str + 1; p[0] = 1; for(int i = 1; i \u0026lt;= n; ++ i) { p[i] = p[i - 1] * P; h[i] = h[i - 1] * P + str[i]; } while( m --) { int l1, r1, l2, r2; cin \u0026gt;\u0026gt; l1 \u0026gt;\u0026gt; r1 \u0026gt;\u0026gt; l2 \u0026gt;\u0026gt; r2; if(get(l1, r1) == get(l2, r2)) { puts(\u0026#34;Yes\u0026#34;); } else { puts(\u0026#34;No\u0026#34;); } } return 0; }   hash算法求两个字符串相同比KMP更好\nKMP更适合循环节。\nC++STL使用 1 2 3 4 5 6 7 8 9 10 11 12 13  vector 可变长数组，倍增的思想 string 处理字符串的利器，substr(), c_str() queue, 队列，进行push(),front(), pop() priority_queue，优先队列，堆，push(), top(), pop() stack 栈，Push(), top(), pop() deque 双端队列 set, map, multiset, multimap 基于平衡二叉树（红黑树）动态维护有序序列 unordered_set, unordered_map, unordered_multiset, unordered_multimap 哈希表 bitset;压位 list用的不多。   vector: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  #include\u0026lt;iostream\u0026gt;#include\u0026lt;cstdio\u0026gt;#include\u0026lt;cstring\u0026gt;#include\u0026lt;algorithm\u0026gt;#include\u0026lt;vector\u0026gt; using namespace std; int main() { vector\u0026lt;int\u0026gt; a(10, 3); vector\u0026lt;int\u0026gt; b[10]; //定义数组  //定义一个长度为10的，初始值为3的vector  //for(auto x : a) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl;  a.size(); //O(1)  a.empty(); a.clear();//清空  /*系统分配空间时，所需时间与空间大小无关，与申请次数有关！！！ 所以尽量减少申请空间的次数。 vector最初分配32的空间，然后如果不够，分配64，然后copy过去之前的元素。 申请长度为2 ^ n的数组，那么需要copy(1 + 2 + 2^n-1) = 2^n可以认为是O(1) 申请空间的次数是log(2^n) = n */ a.front(); a.back(); a.push_back(); a.pop_back(); begin(); end(); []; a \u0026lt; b可以判断两个vector的大小，按字典序比。 return 0; }   下面是模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124  C++ STL简介 vector, 变长数组，倍增的思想 size() 返回元素个数 empty() 返回是否为空 clear() 清空 front()/back() push_back()/pop_back() begin()/end() [] 支持比较运算，按字典序 pair\u0026lt;int, int\u0026gt;p; first, 第一个元素 second, 第二个元素 支持比较运算，以first为第一关键字，以second为第二关键字（字典序） p = make_pair(10, 2); p = {10, 2}; pair\u0026lt;int, pair\u0026lt;int, int\u0026gt;\u0026gt;p;存三个 string，字符串 size()/length() 返回字符串长度 empty() clear() substr(起始下标，(子串长度)) 返回子串 c_str() 返回字符串所在字符数组的起始地址 用于用printf输出 支持加运算： string a = \u0026#34;1\u0026#34;; a += \u0026#34;bcd\u0026#34;; queue, 队列 size() empty() push() 向队尾插入一个元素 front() 返回队头元素 back() 返回队尾元素 pop() 弹出队头元素 priority_queue, 优先队列，默认是大顶堆 size() empty() push() 插入一个元素 top() 返回堆顶元素 pop() 弹出堆顶元素 定义成小顶堆的方式： priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; q; priority_queue\u0026lt;int\u0026gt; heap; 可以通过插入-x实现小顶堆。 stack, 栈 size() empty() push() 向栈顶插入一个元素 top() 返回栈顶元素 pop() 弹出栈顶元素 deque, 双端队列，加强版vector，效率低，尽量不用 size() empty() clear() front()/back() push_back()/pop_back() push_front()/pop_front() begin()/end() 迭代器 [] 支持直接索引 set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列 size() empty() clear() begin()/end() ++, -- 返回前驱和后继，时间复杂度 O(logn) set/multiset set不允许重复元素 insert() 插入一个数 find() 查找一个数，返回迭代器，找不到返回end迭代器 count() 返回某一个数的个数 erase() (1) 输入是一个数x，删除所有x O(k + logn) (2) 输入一个迭代器，删除这个迭代器 lower_bound()/upper_bound() lower_bound(x) 返回大于等于x的最小的数的迭代器 upper_bound(x) 返回大于x的最小的数的迭代器 map/multimap insert() 插入的数是一个pair erase() 输入的参数是pair或者迭代器 find() [] 注意multimap不支持此操作。 时间复杂度是 O(logn) lower_bound()/upper_bound() map\u0026lt;string ,int\u0026gt; a; a[\u0026#34;yxc\u0026#34;] = 1; cout \u0026lt;\u0026lt; a[\u0026#34;yec\u0026#34;] \u0026lt;\u0026lt; endl; unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表 和上面类似，增删改查的时间复杂度是 O(1) 不支持 lower_bound()/upper_bound()， 迭代器的++，--. bitset, 圧位 是bool数组的1/8。🐂 bitset\u0026lt;10000\u0026gt; s; ~s; ~, \u0026amp;, |, ^ \u0026gt;\u0026gt;, \u0026lt;\u0026lt; ==, != [] count() 返回有多少个1 any() 判断是否至少有一个1 none() 判断是否全为0 set() 把所有位置成1 set(k, v) 将第k位变成v reset() 把所有位变成0 flip() 等价于~ flip(k) 把第k位取反 作者：yxc 链接：https://www.acwing.com/blog/content/404/ 来源：AcWing   ","permalink":"https://imingx.github.io/posts/algorithm_02/","summary":"链表与邻接表：树与图的存储 栈与队列：单调队列、单调栈 kmp Trie 并查集 堆 Hash表  链表与邻接表：树与图的存储 用数组来模拟这些结构，不适用struct和STL。目的是为了提高效率\n1 2 3 4 5 6 7  struct Node { int val; Node * next; }; Node * p = new Node();   面试题较多，但是new一个节点是比较慢的，做题不需要。\n用数组模拟单链表 最常用的邻接表，存储图和树。它们都是用邻接表存储的。\n以上是用数组e[N]和数组ne[N]来模拟单链表，如果是不存在，那么取-1。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70  #include\u0026lt;iostream\u0026gt; using namespace std; const int N = 1e5 + 10; // head 表示头结点的下标 // e[i]是节点i的值 // ne[i] 是节点i的next指针 // idx是一个指针，指向当前用到的点。 int head, e[N], ne[N], idx; void init() { head = -1; idx = 0; } //将x插入到头结点 void add_to_head(int x) { e[idx] = x, ne[idx] = head, head = idx, idx ++; } //将x插入到下标是k的点的后面 void add(int k, int x) { e[idx] = x, ne[idx] = ne[k], ne[k] = idx, idx ++; } //删除k后面的节点 void remove(int k) { ne[k] = ne[ne[k]]; } int main() { int m; cin \u0026gt;\u0026gt; m; init(); while ( m --) { int k, x; char op; cin \u0026gt;\u0026gt; op; if (op == \u0026#39;H\u0026#39;) { cin \u0026gt;\u0026gt; x; add_to_head(x); } else if( op == \u0026#39;D\u0026#39;) { cin \u0026gt;\u0026gt; k; if (k == 0) head = ne[head]; else remove(k - 1); }else { cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; x; add(k - 1, x); } } for (int i = head; i !","title":"「Algorithm」02 Data Structure"},{"content":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define rep(i,a,n) for(int i = a; i\u0026lt; n; i++) #define per(i,a,n) for(int i=n-1; i\u0026gt;=a; i--) #define pb push_back #define mp make_pair #define all(x) (x).begin(), (x).end() #define fi first #define se second #define sz(x) ((int)(x).size()) typedef vector\u0026lt;int\u0026gt; VI; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; PII; typedef double db; mt19937 mrand(random_device{}()); const ll mod = 1000000007; int rnd(int x) { return mrand() % x;} ll mulmod(ll a, ll b) {ll res=0;a%=mod;assert(b\u0026gt;=0);for(;b;b\u0026gt;\u0026gt;=1){if(b\u0026amp;1)res+=a%mod;a+=a%mod;}return res;} ll powmod(ll a, ll b) {ll res=1;a%=mod;assert(b\u0026gt;=0);for(;b;b\u0026gt;\u0026gt;=1){if(b\u0026amp;1)res*=a%mod;a*=a%mod;}return res;} ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a;}    13我是是\n 1、编译型语言 需通过编译器（compiler）将源代码编译成机器码，之后才能执行的语言。一般需经过编译（compile）、链接（linker）这两个步骤。编译是把源代码编译成机器码，链接是把各个模块的机器码和依赖库串连起来生成可执行文件。\n**优点：**编译器一般会有预编译的过程对代码进行优化。因为编译只做一次，运行时不需要编译，所以编译型语言的程序执行效率高。可以脱离语言环境独立运行。\n**缺点：**编译之后如果需要修改就需要整个模块重新编译。编译的时候根据对应的运行环境生成机器码，不同的操作系统之间移植就会有问题，需要根据运行的操作系统环境编译不同的可执行文件。\n代表语言：C、C++、Pascal、Object-C以及最近很火的苹果新语言swift\n2、解释型语言 解释性语言的程序不需要编译，相比编译型语言省了道工序，解释性语言在运行程序的时候才逐行翻译。\n**优点：**有良好的平台兼容性，在任何环境中都可以运行，前提是安装了解释器（虚拟机）。灵活，修改代码的时候直接修改就可以，可以快速部署，不用停机维护。\n**缺点：**每次运行的时候都要解释一遍，性能上不如编译型语言。\n代表语言：JavaScript、Python、Erlang、PHP、Perl、Ruby\n3、混合型语言\n既然编译型和解释型各有缺点就会有人想到把两种类型整合起来，取其精华去其糟粕。就出现了半编译型语言。比如C#,C#在编译的时候不是直接编译成机器码而是中间码，.NET平台提供了中间语言运行库运行中间码，中间语言运行库类似于Java虚拟机。.net在编译成IL代码后，保存在dll中，首次运行时由JIT在编译成机器码缓存在内存中，下次直接执行（博友回复指出）。我个人认为抛开一切的偏见C#是这个星球上最好的编程语言。可惜微软的政策限制了C#的推广。\nJava先生成字节码再在Java虚拟机中解释执行。\n严格来说混合型语言属于解释型语言。C#更接近编译型语言。\n动态语言和静态语言\n1、动态语言\n是一类在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构。\n主要动态语言：Object-C、C#、JavaScript、PHP、Python、Erlang。\n2、静态语言\n与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、C、C++。\n3、注意：\n很多人认为解释型语言都是动态语言，这个观点是错的！Java是解释型语言但是不是动态语言，Java不能在运行的时候改变自己结构。反之成立吗？动态语言都是解释型语言。也是错的！Object-C是编译型语言，但是他是动态语言。得益于特有的run time机制（准确说run time不是语法特性是运行时环境，这里不展开）OC代码是可以在运行的时候插入、替换方法的。\nC#也是动态语言，通过C#的反射机制可以动态的插入一段代码执行。所以我说C#是这个星球最好的编程语言。\n动态类型语言和静态类型语言\n1、动态类型语言\n很多网上资料把动态类型语言和动态语言混为一谈，简直是误人子弟。动态类型语言和动态语言是完全不同的两个概念。动态类型语言是指在运行期间才去做数据类型检查的语言，说的是数据类型，动态语言说的是运行是改变结构，说的是代码结构。\n动态类型语言的数据类型不是在编译阶段决定的，而是把类型绑定延后到了运行阶段。\n主要语言：Python、Ruby、Erlang、JavaScript、swift、PHP、Perl。\n2、静态类型语言\n静态语言的数据类型是在编译其间确定的或者说运行之前确定的，编写代码的时候要明确确定变量的数据类型。\n主要语言：C、C++、C#、Java、Object-C。\n3、注意：\n相当一部分程序员，也包括曾经的我，认为解释型语言都是动态类型语言，编译型语言都是静态类型语言。这个也是错的。swift是编译型语言但是它也是动态类型语言。C#和Java是解释型语言也是静态类型语言。\n强类型语言和弱类型语言 1、强类型语言：\n强类型语言，一旦一个变量被指定了某个数据类型，如果不经过强制类型转换，那么它就永远是这个数据类型。你不能把一个整形变量当成一个字符串来处理。\n主要语言：Java、C#、Python、Object-C、Ruby\n2、弱类型语言：\n数据类型可以被忽略，一个变量可以赋不同数据类型的值。一旦给一个整型变量a赋一个字符串值，那么a就变成字符类型。\n主要语言：JavaScript、PHP、C、C++（C和C++有争议，但是确实可以给一个字符变量赋整形值，可能初衷是强类型，形态上接近弱类型）\n3、注意：\n一个语言是不是强类型语言和是不是动态类型语言也没有必然联系。Python是动态类型语言，是强类型语言。JavaScript是动态类型语言，是弱类型语言。Java是静态类型语言，是强类型语言。\n","permalink":"https://imingx.github.io/posts/2/","summary":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; #define rep(i,a,n) for(int i = a; i\u0026lt; n; i++) #define per(i,a,n) for(int i=n-1; i\u0026gt;=a; i--) #define pb push_back #define mp make_pair #define all(x) (x).begin(), (x).end() #define fi first #define se second #define sz(x) ((int)(x).size()) typedef vector\u0026lt;int\u0026gt; VI; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; PII; typedef double db; mt19937 mrand(random_device{}()); const ll mod = 1000000007; int rnd(int x) { return mrand() % x;} ll mulmod(ll a, ll b) {ll res=0;a%=mod;assert(b\u0026gt;=0);for(;b;b\u0026gt;\u0026gt;=1){if(b\u0026amp;1)res+=a%mod;a+=a%mod;}return res;} ll powmod(ll a, ll b) {ll res=1;a%=mod;assert(b\u0026gt;=0);for(;b;b\u0026gt;\u0026gt;=1){if(b\u0026amp;1)res*=a%mod;a*=a%mod;}return res;} ll gcd(ll a, ll b) { return b ?","title":"2"},{"content":"","permalink":"https://imingx.github.io/about-hugo/","summary":"","title":"About Hugo"},{"content":"Hi, I\u0026rsquo;m gmm. Welcome to my fantasy world✨.  An undergraduate student.  Introvert.   A little more about me\u0026hellip; 1 2 3 4 5 6 7 8  const ming = { pronouns: \u0026#34;He\u0026#34; | \u0026#34;Him\u0026#34;, code: [\u0026#34;C\u0026amp;C++\u0026#34;, \u0026#34;Python\u0026#34;, \u0026#34;Java\u0026#34;, \u0026#34;Swift\u0026#34;], tools: [\u0026#34;JetBrains suite\u0026#34;, \u0026#34;Jupyter\u0026#34;], architecture: \u0026#34;Nothing\u0026#34;, interest: \u0026#34;Nothing\u0026#34;, goal: \u0026#34;Do my own and keep shining. Be a pessimistic far traveler\u0026#34; };   I love connecting with different peopleso if you want to say hi, I\u0026rsquo;ll be happy to meet you more!:)","permalink":"https://imingx.github.io/about/","summary":"Hi, I\u0026rsquo;m gmm. Welcome to my fantasy world✨.  An undergraduate student.  Introvert.   A little more about me\u0026hellip; 1 2 3 4 5 6 7 8  const ming = { pronouns: \u0026#34;He\u0026#34; | \u0026#34;Him\u0026#34;, code: [\u0026#34;C\u0026amp;C++\u0026#34;, \u0026#34;Python\u0026#34;, \u0026#34;Java\u0026#34;, \u0026#34;Swift\u0026#34;], tools: [\u0026#34;JetBrains suite\u0026#34;, \u0026#34;Jupyter\u0026#34;], architecture: \u0026#34;Nothing\u0026#34;, interest: \u0026#34;Nothing\u0026#34;, goal: \u0026#34;Do my own and keep shining. Be a pessimistic far traveler\u0026#34; };   I love connecting with different peopleso if you want to say hi, I\u0026rsquo;ll be happy to meet you more!","title":"About"}]